/**
 * macOS native XML tree parsing functionality.
 * @author Martin Kopischke <martin@kopischke.net>
 * @version 1.0.0
 * @license MIT
 * @module
 */

/**
 * An XML node (wraps NSXMLNode and subclasses).
 * NSXMLElement and NSXMLDocument are represented as specialised forms
 * of this object instead of as derived classes. This is the best way to model
 * the polymorphic constructors in Apple’s NSXML API. Just to show why,
 *   var node = $.NSXMLNode.alloc.initWithKind($.NSXMLDocumentKind)
 *   node.isKindOfClass($.NSXMLDocument.class)
 * will return `true`, i.e. NXMLNode constructors return the NSXMLNode
 * subclass that matches the node’s `kind`. This kind of class juggling is
 * impossible to track across glorified JXA wrappers.
 * @summary An XML node (wraps NSXMLNode and subclasses).
 * @class XMLNode
 */
class XMLNode {
  constructor (from) {
    let node
    if (from != null) {
      node = from instanceof XMLNode ? from._raw : from
    }

    /** @private */
    const _NSXMLObject = node || $.NSXMLNode.alloc.initWithKind($.NSXMLInvalidKind)

    // Common XMLNode interface. Mostly wrappers for the NSXMLNode interface,
    // with a bit of `Node` semantics thrown in for convenience.
    Object.defineProperties(this, {
      /**
       * Accessor for the underlying NSXMLNode object.
       * @private {NSXMLNode}
       * @memberof XMLNode
       * @instance
       */
      _raw:  { get: function () { return _NSXMLObject }},
      index: { get: function () { return Number(_NSXMLObject.index) }},
      kind:  { get: function () { return Number(_NSXMLObject.kind) }},
      level: { get: function () { return Number(_NSXMLObject.level) }},
      name:  { get: function () { return _NSXMLObject.name.js }},
      stringValue: {
        get: function () { return _NSXMLObject.stringValue.js},
        set: function (string, resolve) {
          let str = string.toString()
          let res = resolve == true
          _NSXMLObject.setStringValueResolvingEntities(str, res)
        }
      },
      URI: {
        get: function () { return _NSXMLObject.URI.js },
        set: function (uri) { return _NSXMLObject.setURI(uri.toString()) }
      },
      rootDocument: {
        get: function () {
          if (this.kind == S.NSXMLDocumentKind) return this
          let root = _NSXMLObject.rootDocument
          return root.isNil() ? undefined : new XMLNode(root)
        }
      },
      parent: {
        get: function () {
          let parent = _NSXMLObject.parent
          return parent.isNil() ? undefined : new XMLNode(parent)
        }
      },
      detach: {
        value: function () {
          let root = _NSXMLObject.rootDocument
          if (!root.isNil()) _NSXMLObject.detach
        }
      },
      /**
      * Query an XMLNode using XPath.
      * @returns {XMLNode[]} The nodes conforming to the query.
      * @param {string} query - The XPath query to apply.
      * @throws {Error} When the XPath query fails.
      * @memberof XMLNode
      * @instance
      */
      nodesForXPath: {
        value: function (query) {
          let error = $()
          let found = _NSXMLObject.nodesForXPathError(query, error)
          if (found.isNil()) throw error.localizedDescription.js
          return found.js.map(function (n) { return new XMLNode(n) })
        }
      },
      /**
      * Query an XMLNode using XQuery.
      * @returns {XMLNode[]} The nodes conforming to the query.
      * @param {string} query - The XQuery query to evaluate.
      * @param {Object} constants - Constants to pass to the query.
      * @throws {Error} When the XQuery query fails.
      * @memberof XMLNode
      * @instance
      */
      nodesForXQuery: {
        value: function (query, constants) {
          let error = $()
          let consts = constants || null
          let found = _NSXMLObject.objectsForXQueryConstantsError(query, consts, error)
          if (found.isNil()) throw error.localizedDescription.js
          return found.js.map(function (n) { return new XMLNode(n) })
        }
      },
      toString: {
        value: function (options) {
          let opts = Number(options || $.NSXMLNodeOptionsNone)
          return _NSXMLObject.XMLStringWithOptions(opts).js
        }
      },
      toCanonicalString: {
        value: function (withComments) {
          let comments = withComments != null
          return _NSXMLObject.canonicalXMLStringPreservingComments(comments).js
        }
      },
      isConnected: {
        get: function () { return !_NSXMLObject.rootDocument.isNil() }
      },
      isEqualNode: {
        value: function (other) {
          // The NSXMLNode implementation of `isEqual` compares the hashes,
          // thus conforming to the documented `NSObject` protocol behaviour
          // (which is not the same as the undocumented `NSObject` default
          // implementation, see https://stackoverflow.com/a/4253490).
          return _NSXMLObject.isEqual(other._raw)
        }
      },
      isSameNode: {
        value: function (other) {
          let thisNode = _NSXMLObject
          let thisRoot = _NSXMLObject.rootDocument
          let otherNode = other._raw
          let otherRoot = other._raw.rootDocument
          if (
            thisNode.index != otherNode.index ||
            thisNode.kind  != otherNode.kind  ||
            thisNode.level != otherNode.level ||
            thisNode.name  != otherNode.name  ||
            thisRoot.isNil() != otherRoot.isNil()
          ) return false
          let node = thisNode.isEqual(otherNode)
          let root = thisRoot.isNil() ? thisRoot.isEqual(otherRoot) : true
          return node && root
        }
      }
    })

    // Specialised element node interface.
    if (node.kind == $.NSXMLElementKind) {
      Object.defineProperties(this, {
        // TODO: implement element node interface
      })
    }

    // Specialised document node interface.
    if (node.kind == $.NSXMLDocumentKind) {
      Object.defineProperties(this, {
        encoding: {
          get: function () { return _NSXMLObject.characterEncoding.js },
          set: function (e) { _NSXMLObject.characterEncoding = e.toString() }
        },
        contentKind: {
          get: function () { return _NSXMLObject.documentContentKind.js },
          set: function (k) { _NSXMLObject.documentContentKind(d) = k.toString() }
        },
        DTD: {
          get: function () { return _NSXMLObject.DTD },
          set: function (d) { _NSXMLObject.setDTD(d) }
        },
        standalone: {
          get: function () { return _NSXMLObject.isStandalone.js },
          set: function (b) { _NSXMLObject.standalone(b == true) }
        },
        MIMEType: {
          get: function () { return _NSXMLObject.MIMEType.js },
          set: function (m) { _NSXMLObject.setMIMEType(m.toString()) }
        },
        // URI is inherited from XMLNode
        version: {
          get: function () { return _NSXMLObject.version.js },
          set: function (v) { _NSXMLObject.version = v.toString() }
        },
        rootElement: {
          get: function () { return new XMLNode(_NSXMLObject.rootElement) },
          set: function (e) {
            let elem = e instanceof XMLNode ? elem._raw : elem
            _NSXMLObject.setRootElement(elem)
          }
        },
        validate: {
          value: function (quiet) {
            let error = $()
            let valid = _NSXMLObject.validateAndReturnError
            if (!quiet && !valid) throw error.localizedDescription.js
            return valid
          }
        },
        toData: {
          value: function (options) {
            let opts = Number(options || $.NSXMLPreserveAll)
            return _NSXMLObject.XMLDataWithOptions(opts)
          }
        }
      })
    }
  }
}

/**
 * Create XMLNode objects from textual XML input.
 * @class XMLParser
 */
class XMLParser {
  /**
   * Create a document XMLNode from an XML string.
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  static fromXMLDocument (xml, options) {
    let opts = Number(options) || XMLParser.defaultOptions
    let input = xml != null ? xml : ''
    let error = $()
    let doc = $.NSXMLDocument.alloc.initWithXMLStringOptionsError(input, opts, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(doc)
  }

  /**
   * Create an element XMLNode from an XML string.
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  static fromXMLFragment (xml) {
    let input = xml != null ? xml : ''
    let error = $()
    let elem = $.NSXMLElement.alloc.initWithXMLStringError(input, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(elem)
  }

  /**
   * Create a document XMLNode from the contents of an XML file.
   * @returns {XMLNode}
   * @param {string|Path} path - The path to the XML file to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  static fromXMLFile (path, options) {
    let opts = Number(options) || XMLParser.defaultOptions
    let file = path != null ? $(path.toString()).stringByStandardizingPath : ''
    let url = $.NSURL.fileURLWithPath(file)
    let error = $()
    let doc = $.NSXMLDocument.alloc.initWithContentsOfURLOptionsError(url, opts, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(doc)
  }
}

/**
 * Default NSXMLNodeOptions for parsing document XML.
 * @constant {number}
 * @memberof XMLParser
 * @static
 */
XMLParser.defaultOptions = Number($.NSXMLNodeOptionsNone)

/**
 * macOS native XML tree parsing functionality.
 * Because the System Events XML suite is painfully slow and limited,
 * and raw ObjC bridge code is simply painful.
 * @summary macOS native XML tree parsing functionality.
 * @author Martin Kopischke <martin@kopischke.net>
 * @version 1.0.0
 * @license MIT
 * @module
 */

/**
 * An XML node (wraps NSXMLNode and subclasses).
 * NSXMLElement and NSXMLDocument are represented as specialised forms
 * of this object instead of as derived classes. This is the best way to model
 * the polymorphic constructors in Apple’s NSXML API. Just to show why,
 *
 * ```js
 * var node = $.NSXMLNode.alloc.initWithKind($.NSXMLDocumentKind)
 * node.isKindOfClass($.NSXMLDocument.class)
 * ```
 *
 * will return `true`, i.e. NXMLNode constructors return the NSXMLNode
 * subclass that matches the node’s `kind`. This kind of class juggling is
 * impossible to track across glorified JXA wrappers.
 * @summary An XML node (wraps NSXMLNode and subclasses).
 * @class XMLNode
 */
function XMLNode (from) {
  let node = from instanceof XMLNode ? from._raw : from
  if (node == null) node = $.NSXMLNode.alloc.initWithKind($.NSXMLInvalidKind)

  /** @private */
  const _NSXMLObject = node

  /**
   * Accessor for the underlying NSXMLNode object.
   * @member {NSXMLNode} _raw
   * @memberof XMLNode
   * @instance
   * @private
   */
  Object.defineProperty(this, '_raw', { get: function () { return _NSXMLObject }})
}

// Common XMLNode interface. Mostly wrappers for the NSXMLNode interface,
// with a bit of `Node` semantics thrown in for convenience.
Object.defineProperties(XMLNode.prototype, {
  index: { get: function () { return Number(this._raw.index) }},
  kind:  { get: function () { return Number(this._raw.kind) }},
  level: { get: function () { return Number(this._raw.level) }},
  name:  { get: function () { return this._raw.name.js }},
  stringValue: {
    get: function () { return this._raw.stringValue.js},
    set: function (string, resolve) {
      let str = string.toString()
      let res = resolve == true
      this._raw.setStringValueResolvingEntities(str, res)
    }
  },
  URI: {
    get: function () { return this._raw.URI.js },
    set: function (uri) { return this._raw.setURI(uri.toString()) }
  },
  rootDocument: {
    get: function () {
      if (this.kind == S.NSXMLDocumentKind) return this
      let root = this._raw.rootDocument
      return root.isNil() ? undefined : new XMLNode(root)
    }
  },
  parent: {
    get: function () {
      let parent = this._raw.parent
      return parent.isNil() ? undefined : new XMLNode(parent)
    }
  },
  detach: {
    value: function () {
      let root = this._raw.rootDocument
      if (!root.isNil()) this._raw.detach
    }
  },
  /**
  * Query an XMLNode using XPath.
  * @function nodesForXPath
  * @returns {XMLNode[]} The nodes conforming to the query.
  * @param {string} query - The XPath query to evaluate.
  * @throws {Error} When the XPath query fails.
  * @memberof XMLNode
  * @instance
  */
  nodesForXPath: {
    value: function (query) {
      let error = $()
      let found = this._raw.nodesForXPathError(query, error)
      if (found.isNil()) throw error.localizedDescription.js
      return found.js.map(function (n) { return new XMLNode(n) })
    }
  },
  /**
  * Query an XMLNode using XQuery.
  * @function nodesForXQuery
  * @returns {XMLNode[]} The nodes conforming to the query.
  * @param {string} query - The XQuery query to evaluate.
  * @param {Object} constants - Constants to pass to the query.
  * @throws {Error} When the XQuery query fails.
  * @memberof XMLNode
  * @instance
  */
  nodesForXQuery: {
    value: function (query, constants) {
      let error = $()
      let consts = constants || null
      let found = this._raw.objectsForXQueryConstantsError(query, consts, error)
      if (found.isNil()) throw error.localizedDescription.js
      return found.js.map(function (n) { return new XMLNode(n) })
    }
  },
  toString: {
    value: function (options) {
      let opts = Number(options || $.NSXMLNodeOptionsNone)
      return this._raw.XMLStringWithOptions(opts).js
    }
  },
  toCanonicalString: {
    value: function (withComments) {
      let comments = withComments != null
      return this._raw.canonicalXMLStringPreservingComments(comments).js
    }
  },
  isConnected: {
    get: function () { return !this._raw.rootDocument.isNil() }
  },
  isEqualNode: {
    value: function (other) {
      // The NSXMLNode implementation of `isEqual` compares the hashes,
      // thus conforming to the documented `NSObject` protocol behaviour
      // (which is not the same as the undocumented `NSObject` default
      // implementation, see https://stackoverflow.com/a/4253490).
      return this._raw.isEqual(other._raw)
    }
  },
  isSameNode: {
    value: function (other) {
      let thisNode = this._raw
      let thisRoot = this._raw.rootDocument
      let otherNode = other._raw
      let otherRoot = other._raw.rootDocument
      if (
        thisNode.index != otherNode.index ||
        thisNode.kind  != otherNode.kind  ||
        thisNode.level != otherNode.level ||
        thisNode.name  != otherNode.name  ||
        thisRoot.isNil() != otherRoot.isNil()
      ) return false
      let node = thisNode.isEqual(otherNode)
      let root = thisRoot.isNil() ? thisRoot.isEqual(otherRoot) : true
      return node && root
    }
  }
})

// Specialised element node interface.
if (node.kind == $.NSXMLElementKind) {
  Object.defineProperties(XMLNode.prototype, {
    // TODO: implement element node interface
  })
}

// Specialised document node interface.
if (node.kind == $.NSXMLDocumentKind) {
  Object.defineProperties(XMLNode.prototype, {
    encoding: {
      get: function () { return this._raw.characterEncoding.js },
      set: function (e) { this._raw.characterEncoding = e.toString() }
    },
    contentKind: {
      get: function () { return this._raw.documentContentKind.js },
      set: function (k) { this._raw.documentContentKind(d) = k.toString() }
    },
    DTD: {
      get: function () { return this._raw.DTD },
      set: function (d) { this._raw.setDTD(d) }
    },
    standalone: {
      get: function () { return this._raw.isStandalone.js },
      set: function (b) { this._raw.standalone(b == true) }
    },
    MIMEType: {
      get: function () { return this._raw.MIMEType.js },
      set: function (m) { this._raw.setMIMEType(m.toString()) }
    },
    // URI is inherited from XMLNode
    version: {
      get: function () { return this._raw.version.js },
      set: function (v) { this._raw.version = v.toString() }
    },
    rootElement: {
      get: function () { return new XMLNode(this._raw.rootElement) },
      set: function (e) {
        let elem = e instanceof XMLNode ? elem._raw : elem
        this._raw.setRootElement(elem)
      }
    },
    validate: {
      value: function (quiet) {
        let error = $()
        let valid = this._raw.validateAndReturnError
        if (!quiet && !valid) throw error.localizedDescription.js
        return valid
      }
    },
    toData: {
      value: function (options) {
        let opts = Number(options || $.NSXMLPreserveAll)
        return this._raw.XMLDataWithOptions(opts)
      }
    }
  })
}

/**
 * Create XMLNode objects from textual XML input.
 * @namespace XMLParser
 */
const XMLParser = {
  /**
   * Default NSXMLNodeOptions for parsing document XML.
   * @constant {number} defaultOptions
   * @memberof XMLParser
   * @static
   */
  defaultOptions = Number($.NSXMLNodeOptionsNone),
  /**
   * Create a document XMLNode from an XML string.
   * @function fromXMLDocument
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
   fromXMLDocument: function (xml, options) {
    let opts = Number(options) || XMLParser.defaultOptions
    let input = xml != null ? xml : ''
    let error = $()
    let doc = $.NSXMLDocument.alloc.initWithXMLStringOptionsError(input, opts, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(doc)
  },
  /**
   * Create an element XMLNode from an XML string.
   * @function fromXMLFragment
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  fromXMLFragment = function (xml) {
    let input = xml != null ? xml : ''
    let error = $()
    let elem = $.NSXMLElement.alloc.initWithXMLStringError(input, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(elem)
  },
  /**
   * Create a document XMLNode from the contents of an XML file.
   * @function fromXMLFile
   * @returns {XMLNode}
   * @param {string|Path} path - The path to the XML file to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  fromXMLFile = function (path, options) {
    let opts = Number(options) || XMLParser.defaultOptions
    let file = path != null ? $(path.toString()).stringByStandardizingPath : ''
    let url = $.NSURL.fileURLWithPath(file)
    let error = $()
    let doc = $.NSXMLDocument.alloc.initWithContentsOfURLOptionsError(url, opts, error)
    if (doc.isNil()) throw error.localizedDescription.js
    return new XMLNode(doc)
  }
}.freeze()

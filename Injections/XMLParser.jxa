/**
 * **macOS native XML tree parsing functionality.**
 *
 * Because the System Events XML suite is painfully slow and limited,
 * and raw ObjC bridge code is simply painful.
 * @author Martin Kopischke <martin@kopischke.net>
 * @version 1.0.0
 * @license MIT
 * @namespace XMLParser
 */

/** @private */
const minOSVersion = { majorVersion: 10, minorVersion: 12, patchVersion: 0 }
if (!$.NSProcessInfo.processInfo.isOperatingSystemAtLeastVersion(minOSVersion)) {
  const msg = `macOS ${Object.values(minOSVersion).join('.')} required`
  throw new Error(msg)
}

/**
 * An element node.
 * @mixin XMLElement
 * @see {@link XMLNode}
 */
const XMLElementProperties = {
  // TODO: implement element node interface
}

/**
 * A document node.
 * @mixin XMLDocument
 * @see {@link XMLNode}
 */
const XMLDocumentProperties = {
  /**
   * The XML document encoding.
   * @property {number} encoding - NSStringEncoding.
   * @memberof XMLDocument
   */
  encoding: {
    get: function () { return Number(this._raw.characterEncoding.js) },
    set: function (enc) { this._raw.characterEncoding = enc }
  },
  contentKind: {
    get: function () { return this._raw.documentContentKind.js },
    set: function (k) { this._raw.documentContentKind = k.toString() }
  },
  DTD: {
    get: function () { return this._raw.DTD },
    set: function (d) { this._raw.setDTD(d) }
  },
  standalone: {
    get: function () { return this._raw.isStandalone.js },
    set: function (b) { this._raw.standalone(b === true) }
  },
  MIMEType: {
    get: function () { return this._raw.MIMEType.js },
    set: function (m) { this._raw.setMIMEType(m.toString()) }
  },
  // URI is inherited from XMLNode
  version: {
    get: function () { return this._raw.version.js },
    set: function (v) { this._raw.version = v.toString() }
  },
  rootElement: {
    get: function () { return new XMLNode(this._raw.rootElement) },
    set: function (e) {
      const elem = e instanceof XMLNode ? e._raw : e
      this._raw.setRootElement(elem)
    }
  },
  validate: {
    value: function (quiet) {
      var error = $()
      const valid = this._raw.validateAndReturnError(error)
      if (!quiet && !valid) throw new Error(error.localizedDescription.js)
      return valid
    }
  },
  toData: {
    value: function (options) {
      const opts = Number(options || $.NSXMLPreserveAll)
      return this._raw.XMLDataWithOptions(opts)
    }
  }
}

/**
 * An XML node (wraps NSXMLNode and subclasses).
 * NSXMLElement and NSXMLDocument are represented as specialised forms
 * of this object instead of as derived classes. This means that document
 * nodes will include {@link XMLDocument} functionality, and element nodes
 *  will include {@link XMLElement} functionality.
 *
 * This is the best way to model the polymorphic constructors in Apple’s
 * NSXML API, in which the NXMLNode constructor returns the NSXMLNode subclass
 * that matches the node’s `kind`.
 *
 * To construct nodes from XML document files, XML document strings and
 * XML fragments, use the {@link XMLParser.fromXMLFile},
 * {@link XMLParser.fromXMLDocument} and {@link XMLParser.fromXMLFragment}
 * static methods.
 * @example
 * const node = XMLParser.fromXMLFile('/path/to/file.xml')
 * node.encoding != null // true (is an XMLDocument)
 * node.rootElement.encoding != null // false (is an XMLElement)
 * @class XMLNode
 * @param {object} [from] - An XMLNode (or NSXMLNode) object to base the node on.
 * @mixes XMLDocument
 * @mixes XMLElement
 * @see {@link XMLDocument}
 * @see {@link XMLElement}
 * @see {@link XMLParser}
 */
class XMLNode {
  constructor (from) {
    let node = from instanceof XMLNode ? from._raw : from
    if (node == null) node = $.NSXMLNode.alloc.initWithKind($.NSXMLInvalidKind)

    /** @private */
    const _NSXMLObject = node

    /**
     * Accessor for the underlying NSXMLNode object.
     * @member {object} _raw - The raw `NSXMLNode` object underlying the XMLNode.
     * @instance
     * @private
     */
    Object.defineProperty(this, '_raw', { get: function () { return _NSXMLObject } })

    // Specialised element node interface.
    if (_NSXMLObject.kind === $.NSXMLElementKind) {
      Object.defineProperties(this, XMLElementProperties)
    }

    // Specialised document node interface.
    if (_NSXMLObject.kind === $.NSXMLDocumentKind) {
      Object.defineProperties(this, XMLDocumentProperties)
    }
  }

  // Common XMLNode interface. Mostly wrappers for the NSXMLNode interface,
  // with a bit of `Node` semantics thrown in for convenience.
  get index () {
    return Number(this._raw.index)
  }

  get kind () {
    return Number(this._raw.kind)
  }

  get level () {
    return Number(this._raw.level)
  }

  get name () {
    return this._raw.name.js
  }

  get stringValue () { return this._raw.stringValue.js }
  set stringValue (string) {
    this._raw.setStringValueResolvingEntities(string.toString(), false)
  }

  get URI () {
    return this._raw.URI.js
  }

  set URI (uri) {
    return this._raw.setURI(uri.toString())
  }

  get rootDocument () {
    if (this.kind === $.NSXMLDocumentKind) return this
    const root = this._raw.rootDocument
    return root.isNil() ? undefined : new XMLNode(root)
  }

  get parent () {
    const parent = this._raw.parent
    return parent.isNil() ? undefined : new XMLNode(parent)
  }

  detach () {
    const root = this._raw.rootDocument
    if (!root.isNil()) this._raw.detach
  }

  /**
   * Query an XMLNode using XPath.
   * @function nodesForXPath
   * @returns {XMLNode[]} The nodes conforming to the query.
   * @param {string} query - The XPath query to evaluate.
   * @throws {Error} When the XPath query fails.
   * @memberof XMLNode
   * @instance
   */
  nodesForXPath (query) {
    var error = $()
    const found = this._raw.nodesForXPathError(query, error)
    if (found.isNil()) throw new Error(error.localizedDescription.js)
    return found.js.map(function (n) { return new XMLNode(n) })
  }

  /**
   * Query an XMLNode using XQuery.
   * @function nodesForXQuery
   * @returns {XMLNode[]} The nodes conforming to the query.
   * @param {string} query - The XQuery query to evaluate.
   * @param {object} [constants] - Constants to pass to the query.
   * @throws {Error} When the XQuery query fails.
   * @memberof XMLNode
   * @instance
   */
  nodesForXQuery (query, constants) {
    var error = $()
    const consts = constants || null
    const found = this._raw.objectsForXQueryConstantsError(query, consts, error)
    if (found.isNil()) throw new Error(error.localizedDescription.js)
    return found.js.map(function (n) { return new XMLNode(n) })
  }

  toString (options) {
    const opts = Number(options || $.NSXMLNodeOptionsNone)
    return this._raw.XMLStringWithOptions(opts).js
  }

  toCanonicalString (withComments) {
    const comments = withComments === true
    return this._raw.canonicalXMLStringPreservingComments(comments).js
  }

  toJSON () {
    return this.toCanonicalString(true)
  }

  isConnected () {
    return !this._raw.rootDocument.isNil()
  }

  isEqualNode (other) {
    // The NSXMLNode implementation of `isEqual` compares the hashes,
    // thus conforming to the documented `NSObject` protocol behaviour
    // (which is not the same as the undocumented `NSObject` default
    // implementation, see https://stackoverflow.com/a/4253490).
    return this._raw.isEqual(other._raw)
  }

  isSameNode (other) {
    const thisNode = this._raw
    const thisRoot = this._raw.rootDocument
    const otherNode = other._raw
    const otherRoot = other._raw.rootDocument
    if (
      thisNode.index !== otherNode.index ||
      thisNode.kind !== otherNode.kind ||
      thisNode.level !== otherNode.level ||
      thisNode.name !== otherNode.name ||
      thisRoot.isNil() !== otherRoot.isNil()
    ) return false
    const node = thisNode.isEqual(otherNode)
    const root = thisRoot.isNil() ? thisRoot.isEqual(otherRoot) : true
    return node && root
  }
}

const XMLParser = {
  /**
   * Default NSXMLNodeOptions for parsing document XML.
   * @constant {number} defaultOptions
   * @memberof XMLParser
   * @static
   */
  defaultOptions: Number($.NSXMLNodeOptionsNone),
  /**
   * Create a document XMLNode from an XML string.
   * @function fromXMLDocument
   * @returns {XMLNode} The created XMLNode.
   * @param {string} xml - The XML string to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws {Error} When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  fromXMLDocument: function (xml, options) {
    const opts = Number(options) || XMLParser.defaultOptions
    const input = xml != null ? xml : ''
    var error = $()
    const doc = $.NSXMLDocument.alloc.initWithXMLStringOptionsError(input, opts, error)
    if (doc.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(doc)
  },
  /**
   * Create an element XMLNode from an XML string.
   * @function fromXMLFragment
   * @returns {XMLNode} The created XMLNode.
   * @param {string} xml - The XML string to parse.
   * @throws {Error} When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  fromXMLFragment: function (xml) {
    const input = xml != null ? xml : ''
    var error = $()
    const elem = $.NSXMLElement.alloc.initWithXMLStringError(input, error)
    if (elem.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(elem)
  },
  /**
   * Create a document XMLNode from the contents of an XML file.
   * @function fromXMLFile
   * @returns {XMLNode} The created XMLNode.
   * @param {string|Path} path - The path to the XML file to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws {Error} When given invalid input or a a parsing error occurs.
   * @memberof XMLParser
   * @static
   */
  fromXMLFile: function (path, options) {
    const opts = Number(options) || XMLParser.defaultOptions
    const file = path != null ? $(path.toString()).stringByStandardizingPath : ''
    const url = $.NSURL.fileURLWithPath(file)
    var error = $()
    const doc = $.NSXMLDocument.alloc.initWithContentsOfURLOptionsError(url, opts, error)
    if (doc.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(doc)
  }
}

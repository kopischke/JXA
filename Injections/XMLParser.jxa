/**
 * **macOS native XML tree parsing functionality.**
 *
 * Because the System Events XML suite is painfully slow and limited,
 * and raw ObjC bridge code is simply painful.
 * @author Martin Kopischke <martin@kopischke.net>
 * @version 1.0.0
 * @license MIT
 * @module XMLParser
 */

/**
 * An XML node (wraps NSXMLNode and subclasses).
 * NSXMLElement and NSXMLDocument are represented as specialised forms
 * of this object instead of as derived classes. This is the best way to model
 * the polymorphic constructors in Apple’s NSXML API. Just to show why,
 *
 * ```js
 * var node = $.NSXMLNode.alloc.initWithKind($.NSXMLDocumentKind)
 * node.isKindOfClass($.NSXMLDocument.class)
 * ```
 *
 * will return `true`, i.e. NXMLNode constructors return the NSXMLNode
 * subclass that matches the node’s `kind`. This kind of class juggling is
 * impossible to track across glorified JXA wrappers.
 * @class XMLNode
 */
function XMLNode (from) {
  let node = from instanceof XMLNode ? from._raw : from
  if (node == null) node = $.NSXMLNode.alloc.initWithKind($.NSXMLInvalidKind)

  /** @private */
  const _NSXMLObject = node

  /**
   * Accessor for the underlying NSXMLNode object.
   * @member {NSXMLNode} _raw
   * @instance
   * @private
   */
  Object.defineProperty(this, '_raw', { get: function () { return _NSXMLObject } })
}

// Common XMLNode interface. Mostly wrappers for the NSXMLNode interface,
// with a bit of `Node` semantics thrown in for convenience.
Object.defineProperties(XMLNode.prototype, {
  index: { get: function () { return Number(this._raw.index) } },
  kind: { get: function () { return Number(this._raw.kind) } },
  level: { get: function () { return Number(this._raw.level) } },
  name: { get: function () { return this._raw.name.js } },
  stringValue: {
    get: function () { return this._raw.stringValue.js },
    set: function (string, resolve) {
      const str = string.toString()
      const res = resolve === true
      this._raw.setStringValueResolvingEntities(str, res)
    }
  },
  URI: {
    get: function () { return this._raw.URI.js },
    set: function (uri) { return this._raw.setURI(uri.toString()) }
  },
  rootDocument: {
    get: function () {
      if (this.kind === $.NSXMLDocumentKind) return this
      const root = this._raw.rootDocument
      return root.isNil() ? undefined : new XMLNode(root)
    }
  },
  parent: {
    get: function () {
      const parent = this._raw.parent
      return parent.isNil() ? undefined : new XMLNode(parent)
    }
  },
  detach: {
    value: function () {
      const root = this._raw.rootDocument
      if (!root.isNil()) this._raw.detach
    }
  },
  /**
   * Query an XMLNode using XPath.
   * @function nodesForXPath
   * @returns {XMLNode[]} The nodes conforming to the query.
   * @param {string} query - The XPath query to evaluate.
   * @throws When the XPath query fails.
   * @memberof module:XMLParser~XMLNode
   * @instance
   */
  nodesForXPath: {
    value: function (query) {
      var error = $()
      const found = this._raw.nodesForXPathError(query, error)
      if (found.isNil()) throw new Error(error.localizedDescription.js)
      return found.js.map(function (n) { return new XMLNode(n) })
    }
  },
  /**
  * Query an XMLNode using XQuery.
  * @function nodesForXQuery
  * @returns {XMLNode[]} The nodes conforming to the query.
  * @param {string} query - The XQuery query to evaluate.
  * @param {Object} [constants] - Constants to pass to the query.
  * @throws When the XQuery query fails.
  * @memberof module:XMLParser~XMLNode
  * @instance
  */
  nodesForXQuery: {
    value: function (query, constants) {
      var error = $()
      const consts = constants || null
      const found = this._raw.objectsForXQueryConstantsError(query, consts, error)
      if (found.isNil()) throw new Error(error.localizedDescription.js)
      return found.js.map(function (n) { return new XMLNode(n) })
    }
  },
  toString: {
    value: function (options) {
      const opts = Number(options || $.NSXMLNodeOptionsNone)
      return this._raw.XMLStringWithOptions(opts).js
    }
  },
  toCanonicalString: {
    value: function (withComments) {
      const comments = withComments != null
      return this._raw.canonicalXMLStringPreservingComments(comments).js
    }
  },
  isConnected: {
    get: function () { return !this._raw.rootDocument.isNil() }
  },
  isEqualNode: {
    value: function (other) {
      // The NSXMLNode implementation of `isEqual` compares the hashes,
      // thus conforming to the documented `NSObject` protocol behaviour
      // (which is not the same as the undocumented `NSObject` default
      // implementation, see https://stackoverflow.com/a/4253490).
      return this._raw.isEqual(other._raw)
    }
  },
  isSameNode: {
    value: function (other) {
      const thisNode = this._raw
      const thisRoot = this._raw.rootDocument
      const otherNode = other._raw
      const otherRoot = other._raw.rootDocument
      if (
        thisNode.index !== otherNode.index ||
        thisNode.kind !== otherNode.kind ||
        thisNode.level !== otherNode.level ||
        thisNode.name !== otherNode.name ||
        thisRoot.isNil() !== otherRoot.isNil()
      ) return false
      const node = thisNode.isEqual(otherNode)
      const root = thisRoot.isNil() ? thisRoot.isEqual(otherRoot) : true
      return node && root
    }
  }
})

// Specialised element node interface.
if (this._raw.kind === $.NSXMLElementKind) {
  Object.defineProperties(XMLNode.prototype, {
    // TODO: implement element node interface
  })
}

// Specialised document node interface.
if (this._raw.kind === $.NSXMLDocumentKind) {
  Object.defineProperties(XMLNode.prototype, {
    encoding: {
      get: function () { return this._raw.characterEncoding.js },
      set: function (e) { this._raw.characterEncoding = e.toString() }
    },
    contentKind: {
      get: function () { return this._raw.documentContentKind.js },
      set: function (k) { this._raw.documentContentKind = k.toString() }
    },
    DTD: {
      get: function () { return this._raw.DTD },
      set: function (d) { this._raw.setDTD(d) }
    },
    standalone: {
      get: function () { return this._raw.isStandalone.js },
      set: function (b) { this._raw.standalone(b === true) }
    },
    MIMEType: {
      get: function () { return this._raw.MIMEType.js },
      set: function (m) { this._raw.setMIMEType(m.toString()) }
    },
    // URI is inherited from XMLNode
    version: {
      get: function () { return this._raw.version.js },
      set: function (v) { this._raw.version = v.toString() }
    },
    rootElement: {
      get: function () { return new XMLNode(this._raw.rootElement) },
      set: function (e) {
        const elem = e instanceof XMLNode ? e._raw : e
        this._raw.setRootElement(elem)
      }
    },
    validate: {
      value: function (quiet) {
        var error = $()
        const valid = this._raw.validateAndReturnError(error)
        if (!quiet && !valid) throw new Error(error.localizedDescription.js)
        return valid
      }
    },
    toData: {
      value: function (options) {
        const opts = Number(options || $.NSXMLPreserveAll)
        return this._raw.XMLDataWithOptions(opts)
      }
    }
  })
}

const XMLParser = {
  /**
   * Default NSXMLNodeOptions for parsing document XML.
   * @constant {number} defaultOptions
   * @static
   */
  defaultOptions: Number($.NSXMLNodeOptionsNone),
  /**
   * Create a document XMLNode from an XML string.
   * @function fromXMLDocument
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @static
   */
  fromXMLDocument: function (xml, options) {
    const opts = Number(options) || XMLParser.defaultOptions
    const input = xml != null ? xml : ''
    var error = $()
    const doc = $.NSXMLDocument.alloc.initWithXMLStringOptionsError(input, opts, error)
    if (doc.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(doc)
  },
  /**
   * Create an element XMLNode from an XML string.
   * @function fromXMLFragment
   * @returns {XMLNode}
   * @param {string} xml - The XML string to parse.
   * @throws When given invalid input or a a parsing error occurs.
   * @static
   */
  fromXMLFragment: function (xml) {
    const input = xml != null ? xml : ''
    var error = $()
    const elem = $.NSXMLElement.alloc.initWithXMLStringError(input, error)
    if (elem.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(elem)
  },
  /**
   * Create a document XMLNode from the contents of an XML file.
   * @function fromXMLFile
   * @returns {XMLNode}
   * @param {string|Path} path - The path to the XML file to parse.
   * @param {number} options - Bit mask of OR’ed NSXMLNodeOptions.
   * @throws When given invalid input or a a parsing error occurs.
   * @static
   */
  fromXMLFile: function (path, options) {
    const opts = Number(options) || XMLParser.defaultOptions
    const file = path != null ? $(path.toString()).stringByStandardizingPath : ''
    const url = $.NSURL.fileURLWithPath(file)
    var error = $()
    const doc = $.NSXMLDocument.alloc.initWithContentsOfURLOptionsError(url, opts, error)
    if (doc.isNil()) throw new Error(error.localizedDescription.js)
    return new XMLNode(doc)
  }
}.freeze()
